---
title: "OSCA"
format: html
---
# https://bioconductor.org/books/release/OSCA/
# Package installation

```{r, eval=FALSE}
BiocManager::install(version = "3.22")
BiocManager::install(remotes::local_package_deps("OSCA", dependencies=TRUE))
devtools::install_github("duncantl/CodeDepends")
install.packages("PCAtools")
BiocManager::install(c(
    "OSCA.intro",
    "OSCA.workflows",
    "OSCA.multisample",
  ))
# "OSCA.basic", "OSCA.advanced" did not install as they require dependency mbkmeans
```

# OSCA Introduction

## Different experimental protocols of single-cell RNA-Seq
![](images/protocol_diff.png)
- **Droplet-based protocols:** 10X Genomics, inDrop and Drop-seq
- **Plate-based protocols with UMIs:** CEL-seq and MARS-seq
- **Plate-based protocols with reads** Smart-seq2
- Others like sciRNA-seq
- UMI-based methods mitigate the effects of PCR amplification noise (https://www.lexogen.com/blog/rna-lexicon-what-are-unique-molecular-identifiers-umis-and-why-do-we-need-them/)

## How many cells should be captured, and to what depth they should be sequenced?
- More cells required (for rare cell subpopulations)
- More sequencing depth (quantify differences)
- Typical droplet-based experiments capture 10,000 to 100,000 cells, with 1,000 to 10,000 UMIs per cell

## Should we obtain more cells per sample at the cost of being able to sequence fewer samples?
- Depends on:
  - Sizes of the subpopulations
  - Variability across different samples and conditions

## SingleCellExperiment class
![](images/SingleCellExperiment.png)

## scRNAseq analysis general workflow
![](images/scRNAseq_analysis_workflow.png)

```{r, eval=FALSE}
# Getting scRNA-seq datasets---------------------------------------------------------------------

### Reading counts into R ###
### From tabular formats ###
# Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE85241

library(BiocFileCache)
bfc <- BiocFileCache(ask=FALSE)
url <- file.path("ftp://ftp.ncbi.nlm.nih.gov/geo/series",
    "GSE85nnn/GSE85241/suppl",
    "GSE85241%5Fcellsystems%5Fdataset%5F4donors%5Fupdated%2Ecsv%2Egz")

# Making a symbolic link so that the later code can pretend
# that we downloaded the file into the local directory.
muraro.fname <- bfcrpath(bfc, url)
local.name <- URLdecode(basename(url))
unlink(local.name)
if (.Platform$OS.type=="windows") {
    file.copy(muraro.fname, paste0("OSCA/datasets/", local.name))
} else {
    file.symlink(muraro.fname, local.name)
}

mat <- as.matrix(read.delim("OSCA/datasets/GSE85241_cellsystems_dataset_4donors_updated.csv.gz"))
dim(mat) # number of rows, number of columns

# More efficient approach is to read in the table in sparse format
library(scuttle)
sparse.mat <- readSparseCounts("OSCA/datasets/GSE85241_cellsystems_dataset_4donors_updated.csv.gz")
dim(sparse.mat)

# We can see that it uses less memory compared to 'mat'.
object.size(sparse.mat)
object.size(mat)

# Data: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE61533
# When data is stored in Excel format
library(readxl)
all.counts <- read_excel("OSCA/datasets/GSE61533_HTSEQ_count_results.xls")
gene.names <- all.counts$ID
all.counts <- as.matrix(all.counts[,-1])
rownames(all.counts) <- gene.names
dim(all.counts)

### From Cellranger output ###
# For 10X Genomics data, the Cellranger software suite will produce an output directory containing counts and feature/barcode annotations
# Data: 

library(DropletTestFiles)
cached <- getTestFile("tenx-2.1.0-pbmc4k/1.0.0/filtered.tar.gz")
fpath <- "OSCA/datasets/tenx-2.1.0-pbmc4k"
untar(cached, exdir=fpath)

library(DropletUtils)
sce <- read10xCounts("OSCA/datasets/tenx-2.1.0-pbmc4k/filtered_gene_bc_matrices/GRCh38")
sce # SingleCellExperiment class

# Reading multiple count matrices in a SingleCellExperiment class
# sce <- read10xCounts(c(dirA, dirB))
# Each directory containing barcodes, genes and matrices

### From HDF5-based formats ###
# Allows storage of both expression values and associated gene and cell annotations in the same file
# Analysis can be performed without reading all data into R (Memory efficient)

# Flavor: H5AD format
library(zellkonverter)
demo <- system.file("extdata", "krumsiek11.h5ad", package = "zellkonverter")
sce <- readH5AD(demo)
sce

# Flavor: Loom format
library(LoomExperiment)
demo <- system.file("extdata", "L1_DRG_20_example.loom", package = "LoomExperiment")
scle <- import(demo, type="SingleCellLoomExperiment")
scle

# The SingleCellExperiment Class---------------------------------------------------------------------
library(SingleCellExperiment)
library(BiocFileCache)
bfc <- BiocFileCache("OSCA/datasets/raw_data", ask = FALSE)
calero.counts <- bfcrpath(bfc, file.path("https://www.ebi.ac.uk/biostudies", 
    "files/E-MTAB-5522/counts_Calero_20160113.tsv"))

mat <- read.delim(calero.counts, header=TRUE, row.names=1, check.names=FALSE)

# Only considering endogenous genes for now.
spike.mat <- mat[grepl("^ERCC-", rownames(mat)),]
mat <- mat[grepl("^ENSMUSG", rownames(mat)),] 

# Splitting off the gene length column.
gene.length <- mat[,1]
mat <- as.matrix(mat[,-1]) 

dim(mat)

# Counts matrix can be provided as a list
sce <- SingleCellExperiment(assays = list(counts = mat)) 
# Check assays in SingleCellExperiment using assayNames(sce) and assays(sce)
# Getting the assays from sce
assay(sce, "counts")
counts(sce)
# Adding log-normalized counts to the same sce
sce <- scuttle::logNormCounts(sce)
sce

# Metadata
bfc <- BiocFileCache("OSCA/datasets", ask = FALSE)
lun.sdrf <- bfcrpath(bfc, file.path("https://www.ebi.ac.uk/arrayexpress/files",
    "E-MTAB-5522/E-MTAB-5522.sdrf.txt"))
coldata <- read.delim(lun.sdrf, check.names=FALSE)
# Only keeping the cells involved in the count matrix in 'mat'.
coldata <- coldata[coldata[,"Derived Array Data File"]=="counts_Calero_20160113.tsv",]
# Only keeping interesting columns, and setting the library names as the row names.
coldata <- DataFrame(
    genotype=coldata[,"Characteristics[genotype]"],
    phenotype=coldata[,"Characteristics[phenotype]"],
    spike_in=coldata[,"Factor Value[spike-in addition]"],
    row.names=coldata[,"Source Name"]
)

# Add the metadata to SingleCellExperiment class from scratch along with the counts data
sce <- SingleCellExperiment(assays = list(counts=mat), colData=coldata)
# Or add the metadata to an existing SingleCellExperiment class
sce <- SingleCellExperiment(list(counts=mat))
colData(sce) <- coldata
sce
# Or each metadata column one by one
sce <- SingleCellExperiment(list(counts=mat))
sce$phenotype <- coldata$phenotype
colData(sce)

# It is very important to make sure that the rows of colData match the columns of count matrix.
identical(rownames(coldata), colnames(mat))

sce <- scuttle::addPerCellQC(sce)
colData(sce)

# Feature level annotation is stored in rowData slot
rowData(sce)$Length <- gene.length
sce <- scuttle::addPerFeatureQC(sce)
rowData(sce)

# rowRanges slot holds genomic coordinates if available in the form of a GRanges or GRangesList
rowRanges(sce)
# We populate the rowRanges depending on the organism and annotation used during alignment and quantification
# Ensembl 82
mm10.gtf <- bfcrpath(bfc, file.path("http://ftp.ensembl.org/pub/release-82",
    "gtf/mus_musculus/Mus_musculus.GRCm38.82.gtf.gz"))
gene.data <- rtracklayer::import(mm10.gtf)

# Cleaning up the object.
gene.data <- gene.data[gene.data$type=="gene"]
names(gene.data) <- gene.data$gene_id
is.gene.related <- grep("gene_", colnames(mcols(gene.data)))
mcols(gene.data) <- mcols(gene.data)[,is.gene.related]

rowRanges(sce) <- gene.data[rownames(sce)]
rowRanges(sce)[1:10,]

# Other kinds of metadata can be stored in the metadata slot
# For example, we have some favorite genes (e.g., highly variable genes) that we want to store inside of sce for use in our analysis at a later point
my_genes <- c("gene_1", "gene_5")
metadata(sce) <- list(favorite_genes = my_genes)
metadata(sce)
# Appending more info to metadata slot
your_genes <- c("gene_4", "gene_8")
metadata(sce)$your_genes <- your_genes
metadata(sce)
# These will not be synchronized with the rows or columns when subsetting or combining as they are not related. Thus, related data must be stored in rowData() or colData()

# Subsetting and combining
# Advantage: Operations on the rows or columns of the expression data are synchronized with the associated annotation

first.10 <- sce[,1:10]
colData(first.10)

# Subsetting only wild-type phenotype (subsetting the colData)
wt.only <- sce[, sce$phenotype == "wild type phenotype"]
ncol(counts(wt.only))

# Subsetting the rowData
coding.only <- sce[rowData(sce)$gene_biotype == "protein_coding"]
nrow(counts(coding.only))

# Combining sce objects (class would take care of combining both the expression values and the associated annotation)
sce2 <- cbind(sce, sce)
sce2 <- rbind(sce, sce) # assuming all objects have the same column annotation values and compatible row annotation fields

### Dimensionality reduction results ###
# The reducedDims slot is specially designed to store reduced dimensionality representations of the primary data
sce <- scater::logNormCounts(sce)
sce <- scater::runPCA(sce) # PCA
dim(reducedDim(sce, "PCA"))
sce <- scater::runTSNE(sce, perplexity = 0.1) # tSNE
head(reducedDim(sce, "TSNE"))

# names of dimensionality reduction results
reducedDims(sce)

# Manual addition of dimensionality reduction results to sce
u <- uwot::umap(t(logcounts(sce)), n_neighbors = 2)
reducedDim(sce, "UMAP_uwot") <- u
reducedDims(sce)

### Alternative Experiments ###
# Distinct set of features for the same set of samples/cells e.g., per-cell counts for spike-in transcripts
# Operations need to be performed separately for these features
spike_se <- SummarizedExperiment(list(counts=spike.mat[,-1]))
altExp(sce, "spike") <- spike_se
altExps(sce)

# If we subset out data, the alternative experiment would also be subset
sub <- sce[,1:2] # retain only two samples.
altExp(sub, "spike")

### Size factors ###
sce <- scran::computeSumFactors(sce)
summary(sizeFactors(sce))

# Or manually add size factors
sizeFactors(sce) <- scater::librarySizeFactors(sce)
summary(sizeFactors(sce))

### Column labels ###
colLabels(sce) <- scran::clusterCells(sce, use.dimred="PCA")
table(colLabels(sce))

# Analysis overview---------------------------------------------------------------------

# Typical workflow involves:
# - Quality control to remove low-quality cells. Common metrics include the total counts per cell, the proportion of spike-in or mitochondrial reads and the number of detected features.
# - Normalizing expression values to eliminate cell-specific biases (e.g., in capture efficiency). Log transformation is also applied to adjust for the mean-variance relationship.
# - Feature selection using genes that are highly variable.
# - Dimensionality reduction for data compaction and visualization.
# - Clustering cells into groups according to similarities in their (normalized) expression profiles.

library(scRNAseq)
sce <- MacoskoRetinaData()

# Quality control (using mitochondrial genes).
library(scater)
is.mito <- grepl("^MT-", rownames(sce))
qcstats <- perCellQCMetrics(sce, subsets=list(Mito=is.mito))
# Output
#   |-- sum
#   |-- detected
#   |-- percent.top
#   +-- subsets
#       |-- Mito
#       |   |-- sum
#       |   |-- detected
#       |   +-- percent
#       +-- Sex 
#           |-- sum
#           |-- detected
#           +-- percent
# Sum - Sum of counts or the library size
# Detected - The number of detected features
# Percent.top - The percentage of counts in the top features (provides a measure of library complexity)
# If subsets is specified, these statistics are also computed for each subset of features

filtered <- quickPerCellQC(qcstats, percent_subsets="subsets_Mito_percent")
sce <- sce[, !filtered$discard]

# Normalization.
sce <- logNormCounts(sce) # Adds logcounts to assays and sizeFactor to colData

# Feature selection.
library(scran)
dec <- modelGeneVar(sce)
hvg <- getTopHVGs(dec, prop=0.1) # Top 10 % genes

# PCA.
library(scater)
set.seed(1234)
sce <- runPCA(sce, ncomponents=25, subset_row=hvg) # Adds PCA components to reducedDimNames

# Clustering.
library(bluster)
colLabels(sce) <- clusterCells(sce, use.dimred='PCA', BLUSPARAM=NNGraphParam(cluster.fun="louvain")) # Adds label to colData

# Visualization.
sce <- runUMAP(sce, dimred = 'PCA') # Adds UMAP dimensions to reducedDimNames
plotUMAP(sce, colour_by="label")

# Marker detection.
markers <- findMarkers(sce, test.type="wilcox", direction="up", lfc=1)

### Analysis when multiple batches are present ###
sce <- SegerstolpePancreasData()

# Quality control (using ERCCs).
qcstats <- perCellQCMetrics(sce)
filtered <- quickPerCellQC(qcstats, percent_subsets="altexps_ERCC_percent")
sce <- sce[, !filtered$discard]

# Normalization.
sce <- logNormCounts(sce)

# Feature selection, blocking on the individual of origin.
dec <- modelGeneVar(sce, block=sce$individual)
hvg <- getTopHVGs(dec, prop=0.1)

# Batch correction.
library(batchelor)
set.seed(1234)
sce <- correctExperiments(sce, batch=sce$individual, subset.row=hvg, correct.all=TRUE)

# Clustering.
colLabels(sce) <- clusterCells(sce, use.dimred='corrected')

# Visualization.
sce <- runUMAP(sce, dimred = 'corrected')
gridExtra::grid.arrange(
    plotUMAP(sce, colour_by="label"),
    plotUMAP(sce, colour_by="individual"),
    ncol=2
)

# Marker detection, blocking on the individual of origin.
markers <- findMarkers(sce, test.type="wilcox", direction="up", lfc=1)
```

# OSCA Basics

```{r, eval=FALSE}

```